// Generated by HLC 4.2.5 (HL v4)
#define HLC_BOOT
#include <hlc.h>
#include <armory/logicnode/SleepNode.h>
void armory_logicnode_LogicNode_new(armory__logicnode__LogicNode,armory__logicnode__LogicTree);
extern hl_type t$hl_types_ArrayObj;
void hl_types_ArrayObj_new(hl__types__ArrayObj);
void armory_logicnode_SleepNode_stop(armory__logicnode__SleepNode);
extern hl_type t$fun_22d5776;
#include <iron/Trait.h>
void iron_Trait_notifyOnRemove(iron__Trait,vclosure*);
#include <armory/logicnode/LogicNodeLink.h>
#include <hl/types/ArrayBytes_Int.h>
#include <hl/types/ArrayBytes_Float.h>
extern hl_type t$_dyn;
void armory_logicnode_SleepNode_done(armory__logicnode__SleepNode);
vvirtual* iron_system_Tween_timer(double,vclosure*);
int hl_types_ArrayObj_push(hl__types__ArrayObj,vdynamic*);
void armory_logicnode_LogicNode_runOutput(armory__logicnode__LogicNode,int);
extern hl_type t$vrt_3a35fd2;
void iron_system_Tween_stop(vvirtual*);

void armory_logicnode_SleepNode_new(armory__logicnode__SleepNode r0,armory__logicnode__LogicTree r1) {
	hl__types__ArrayObj r3;
	vclosure *r4;
	armory_logicnode_LogicNode_new(((armory__logicnode__LogicNode)r0),r1);
	r3 = (hl__types__ArrayObj)hl_alloc_obj(&t$hl_types_ArrayObj);
	hl_types_ArrayObj_new(r3);
	r0->sleepArray = r3;
	if( r1 == NULL ) hl_null_access();
	r4 = hl_alloc_closure_ptr(&t$fun_22d5776,armory_logicnode_SleepNode_stop,r0);
	iron_Trait_notifyOnRemove(((iron__Trait)r1),r4);
	return;
}

void armory_logicnode_SleepNode_run(armory__logicnode__SleepNode r0,int r1) {
	vvirtual *r11;
	armory__logicnode__LogicNodeLink r5;
	hl__types__ArrayObj r2;
	armory__logicnode__LogicNode r9;
	vclosure *r12;
	double r10;
	vdynamic *r6;
	varray *r7;
	int r3, r4;
	r2 = r0->inputs;
	if( r2 == NULL ) hl_null_access();
	r3 = 1;
	r4 = r2->length;
	if( ((unsigned)r3) < ((unsigned)r4) ) goto label$e6dc51c_2_7;
	r5 = NULL;
	goto label$e6dc51c_2_10;
	label$e6dc51c_2_7:
	r7 = r2->array;
	r6 = ((vdynamic**)(r7 + 1))[r3];
	r5 = (armory__logicnode__LogicNodeLink)r6;
	label$e6dc51c_2_10:
	if( r5 == NULL ) hl_null_access();
	r9 = r5->fromNode;
	if( r9 == NULL ) hl_null_access();
	r3 = r5->fromIndex;
	r6 = ((vdynamic* (*)(armory__logicnode__LogicNode,int))r9->$type->vobj_proto[1])(r9,r3);
	r10 = (double)hl_dyn_castd(&r6,&t$_dyn);
	r12 = hl_alloc_closure_ptr(&t$fun_22d5776,armory_logicnode_SleepNode_done,r0);
	r11 = iron_system_Tween_timer(r10,r12);
	r2 = r0->sleepArray;
	if( r2 == NULL ) hl_null_access();
	r3 = hl_types_ArrayObj_push(r2,((vdynamic*)r11));
	return;
}

void armory_logicnode_SleepNode_done(armory__logicnode__SleepNode r0) {
	int r2;
	r2 = 0;
	armory_logicnode_LogicNode_runOutput(((armory__logicnode__LogicNode)r0),r2);
	return;
}

void armory_logicnode_SleepNode_stop(armory__logicnode__SleepNode r0) {
	vvirtual *r5;
	hl__types__ArrayObj r3;
	vdynamic *r6;
	varray *r7;
	int r1, r4;
	r1 = 0;
	r3 = r0->sleepArray;
	label$e6dc51c_4_2:
	if( r3 == NULL ) hl_null_access();
	r4 = r3->length;
	if( r1 >= r4 ) goto label$e6dc51c_4_16;
	r4 = r3->length;
	if( ((unsigned)r1) < ((unsigned)r4) ) goto label$e6dc51c_4_10;
	r5 = NULL;
	goto label$e6dc51c_4_13;
	label$e6dc51c_4_10:
	r7 = r3->array;
	r6 = ((vdynamic**)(r7 + 1))[r1];
	r5 = hl_to_virtual(&t$vrt_3a35fd2,(vdynamic*)r6);
	label$e6dc51c_4_13:
	++r1;
	iron_system_Tween_stop(r5);
	goto label$e6dc51c_4_2;
	label$e6dc51c_4_16:
	return;
}

